---
title: Riferimento protezione dagli exploit
keywords: mitigazioni, vulnerabilità, vulnerabilità, mitigazione, exploit, exploit, emet
description: Dettagli sul funzionamento della funzionalità di protezione degli exploit in Windows 10
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: 7300ed2a4dc2623a8f936006ce7de3a5204712f0
ms.sourcegitcommit: 4fb1226d5875bf5b9b29252596855a6562cea9ae
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/08/2021
ms.locfileid: "52844542"
---
# <a name="exploit-protection-reference"></a>Informazioni di riferimento sulla protezione degli exploit

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Si applica a:**
- [Microsoft Defender per endpoint](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

>Vuoi provare Microsoft Defender per Endpoint? [Iscriversi per una versione di valutazione gratuita.](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

La protezione degli exploit offre protezioni avanzate per le applicazioni che il Pro IT può applicare dopo che lo sviluppatore ha compilato e distribuito il software.

Questo articolo ti aiuta a comprendere il funzionamento della protezione degli exploit, sia a livello di criteri che a livello di mitigazione individuale, per aiutarti a creare e applicare correttamente i criteri di protezione da exploit.

## <a name="how-mitigations-are-applied"></a>Modalità di applicazione delle mitigazioni

Le mitigazioni di Protezione da exploit vengono applicate per ogni applicazione.

Le mitigazioni vengono configurate tramite una voce del Registro di sistema per ogni programma per cui si configurano le protezioni. Queste impostazioni vengono archiviate nella voce del Registro di sistema **MitigationOptions** per ogni programma (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Vengono applicate quando si riavvia il programma e rimangono effettive fino a quando non vengono modificate e riavviate di nuovo.

> [!IMPORTANT]
> Opzioni di esecuzione dei file di immagine consente solo di specificare un nome file o un percorso e non un numero di versione, un'architettura o qualsiasi altro elemento di differenziazione. Prestare attenzione alle mitigazioni per le app con nomi o percorsi univoci, applicandoli solo ai dispositivi in cui è stata testata la versione e l'architettura dell'applicazione.

Se si configurano le mitigazioni di protezione da exploit utilizzando un file di configurazione XML, tramite PowerShell, Criteri di gruppo o MDM, durante l'elaborazione di questo file di configurazione XML, verranno configurate automaticamente singole impostazioni del Registro di sistema.

Quando il criterio che distribuisce il file XML non viene più applicato, le impostazioni distribuite da questo file di configurazione XML non verranno rimosse automaticamente. Per rimuovere le impostazioni di Protezione dagli exploit, esporta la configurazione XML da un dispositivo Windows 10 e distribuisci questo nuovo file XML. In alternativa, Microsoft fornisce un file XML come parte delle Sicurezza di Windows di base per la reimpostazione delle impostazioni di Protezione da exploit.

Per reimpostare le impostazioni di protezione da exploit tramite PowerShell, è possibile utilizzare il comando seguente:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
Di seguito è riportata EP-reset.xml distribuzione con le Sicurezza di Windows di base:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Informazioni di riferimento sulla mitigazione

Nelle sezioni seguenti vengono descritte in dettaglio le protezioni fornite da ogni mitigazione della protezione dagli exploit, le considerazioni sulla compatibilità per la mitigazione e le opzioni di configurazione disponibili.

## <a name="arbitrary-code-guard"></a>Protezione del codice arbitrario

### <a name="description"></a>Descrizione

La protezione del codice arbitrario consente di proteggersi da un utente malintenzionato che carica il codice scelto in memoria tramite una vulnerabilità di sicurezza della memoria ed è in grado di eseguire tale codice.

La protezione del codice arbitrario protegge un'applicazione dall'esecuzione di codice generato dinamicamente (codice non caricato, ad esempio, dall'exe stesso o da una dll). La protezione del codice arbitrario funziona impedendo che la memoria venga contrassegnata come eseguibile. Quando un'applicazione tenta di [allocare memoria,](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)controlliamo i flag di protezione. La memoria può essere allocata con flag di protezione di lettura, scrittura e/o esecuzione. Se l'allocazione tenta di includere il flag [*di*](/windows/win32/memory/memory-protection-constants) protezione dell'esecuzione, l'allocazione di memoria ha esito negativo e restituisce un codice di errore (STATUS_DYNAMIC_CODE_BLOCKED). Analogamente, se un'applicazione [](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) tenta di modificare i flag di protezione [](/windows/win32/memory/memory-protection-constants) della memoria già allocati e include il flag di protezione esecuzione, la modifica delle autorizzazioni ha esito negativo e restituisce un codice di errore (STATUS_DYNAMIC_CODE_BLOCKED).

Impedendo l'impostazione del flag *execute,* la funzionalità di prevenzione dell'esecuzione dei dati di Windows 10 può quindi proteggersi dal puntatore all'istruzione impostato su tale memoria ed eseguire tale codice.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

La protezione del codice arbitrario impedisce l'allocazione di memoria come eseguibile, che presenta un problema di compatibilità con approcci come i compilatori JIT (Just-in-Time). La maggior parte dei browser moderni, ad esempio, compilerà JavaScript in codice nativo per ottimizzare le prestazioni. Per supportare questa mitigazione, è necessario riarchiviare tali elementi per spostare la compilazione JIT all'esterno del processo protetto. Altre applicazioni la cui progettazione genera dinamicamente codice da script o da altri linguaggi intermedi saranno incompatibili con questa mitigazione.

### <a name="configuration-options"></a>Opzioni di configurazione

**Consenti rifiuto esplicito thread** - È possibile configurare la mitigazione per consentire a un singolo thread di rifiutare esplicitamente questa protezione. Lo sviluppatore deve aver scritto l'applicazione con consapevolezza di questa mitigazione e aver chiamato l'API [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) con il *parametro ThreadInformation* impostato su **ThreadDynamicCodePolicy** per poter eseguire codice dinamico su questo thread.

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Advanced Hunting in [Defender for Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-low-integrity-images"></a>Bloccare le immagini con integrità bassa

### <a name="description"></a>Descrizione

Blocca immagini con integrità bassa impedisce all'applicazione di caricare file non attendibili, in genere perché sono stati scaricati da Internet da un browser in modalità sandbox.

Questa mitigazione blocca il caricamento dell'immagine se l'immagine dispone di una voce di controllo di accesso (ACE, Access Control Entry) che concede l'accesso ai processi Low IL e che non dispone di un'etichetta di attendibilità ACE. Viene implementato dal gestore della memoria, che blocca il mapping del file in memoria. Se un'applicazione tenta di mappare un'immagine con integrità bassa, verrà generato un STATUS_ACCESS_DENIED errore. Per informazioni dettagliate sul funzionamento dei livelli di integrità, vedere [Mandatory Integrity Control.](/windows/win32/secauthz/mandatory-integrity-control)

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Blocca immagini con integrità bassa impedirà all'applicazione di caricare file scaricati da Internet. Se il flusso di lavoro dell'applicazione richiede il caricamento di immagini scaricate, è necessario assicurarsi che siano scaricate da un processo con attendibilità superiore o che siano state esplicitamente rietichettate per applicare questa mitigazione.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-remote-images"></a>Bloccare le immagini remote

### <a name="description"></a>Descrizione

Il blocco delle immagini remote consente di impedire all'applicazione di caricare file ospitati in un dispositivo remoto, ad esempio una condivisione UNC. Il blocco delle immagini remote consente di proteggere dal caricamento di file binari in memoria presenti in un dispositivo esterno controllato dall'autore dell'attacco.

Questa mitigazione bloccherà il caricamento dell'immagine se l'immagine viene determinata in un dispositivo remoto. Viene implementato dal gestore della memoria, che blocca il mapping del file in memoria. Se un'applicazione tenta di eseguire il mapping di un file remoto, verrà generato un STATUS_ACCESS_DENIED errore.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Blocca immagini remote impedirà all'applicazione di caricare immagini da dispositivi remoti. Se l'applicazione carica file o plug-in da dispositivi remoti, non sarà compatibile con questa mitigazione.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-untrusted-fonts"></a>Blocca tipi di carattere non attendibili

### <a name="description"></a>Descrizione

Blocca tipi di carattere non attendibili riduce il rischio di un difetto nell'analisi dei tipi di carattere che porta l'utente malintenzionato a eseguire codice nel dispositivo. Solo i tipi di carattere installati nella directory windows\fonts verranno caricati per l'elaborazione da GDI.

Questa mitigazione viene implementata in GDI, che convalida il percorso del file. Se il file non si trova nella directory dei tipi di carattere di sistema, il tipo di carattere non verrà caricato per l'analisi e la chiamata avrà esito negativo.

Questa mitigazione si aggiunge alla mitigazione predefinita fornita in Windows 10 1607 e versioni successive, che sposta l'analisi dei tipi di carattere fuori dal kernel e in un contenitore di app in modalità utente. Qualsiasi exploit basato sull'analisi dei tipi di carattere, di conseguenza, si verifica in un contesto in modalità sandbox e isolato, riducendo in modo significativo il rischio. Per informazioni dettagliate su questa mitigazione, vedere il blog [Hardening Windows 10 with zero-day exploit mitigations](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

L'utilizzo più comune dei tipi di carattere al di fuori della directory dei tipi di carattere di sistema è con [i tipi di carattere Web.](/typography/fonts/font-faq#web) I browser moderni, ad esempio Microsoft Edge, usano DirectWrite anziché GDI e non sono influenzati. Tuttavia, i browser legacy, ad esempio Internet Explorer 11 (e la modalità Internet Explorer nel nuovo Microsoft Edge) possono essere influenzati, in particolare con applicazioni come Office 365, che usano glifi dei tipi di carattere per visualizzare l'interfaccia utente.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="code-integrity-guard"></a>Protezione dell'integrità del codice

### <a name="description"></a>Descrizione

Protezione dell'integrità del codice garantisce che tutti i file binari caricati in un processo siano firmati digitalmente da Microsoft. Code Integrity Guard include firme [WHQL](/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), che consentiranno l'esecuzione di driver approvati da WHQL all'interno del processo.

Questa mitigazione viene implementata all'interno del gestore della memoria, che blocca il mapping del binario in memoria. Se si tenta di caricare un file binario non firmato da Microsoft, la gestione della memoria restituirà l'errore STATUS_INVALID_IMAGE_HASH. Bloccando a livello di gestione della memoria, si evita che entrambi i file binari caricati dal processo e i file binari inseriti nel processo.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Questa mitigazione blocca in modo specifico qualsiasi file binario non firmato da Microsoft. Di conseguenza, sarà incompatibile con la maggior parte del software di terze parti, a meno che tale software non sia distribuito (e firmato digitalmente da) il Microsoft Store e non sia selezionata l'opzione per consentire il caricamento di immagini firmate dal Microsoft Store.

### <a name="configuration-options"></a>Opzioni di configurazione

Consenti anche il caricamento delle immagini firmate da **Microsoft Store:** le applicazioni distribuite dal Microsoft Store saranno firmate digitalmente dal Microsoft Store e l'aggiunta di questa configurazione consentirà ai file binari che hanno attraversato il processo di certificazione dell'archivio di essere caricati dall'applicazione.

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="control-flow-guard-cfg"></a>Control flow guard (CFG)

### <a name="description"></a>Descrizione

Control flow guard (CFG) riduce il rischio che gli utenti malintenzionati utilizzino vulnerabilità di danneggiamento della memoria proteggendo le chiamate di funzione indirette. Ad esempio, un utente malintenzionato potrebbe utilizzare una vulnerabilità di overflow del buffer per sovrascrivere la memoria contenente un puntatore a funzione e sostituire tale puntatore a funzione con un puntatore al codice eseguibile di propria scelta (che potrebbe essere stato inserito anche nel programma).

Questa mitigazione viene fornita mediante l'inserimento di un altro controllo in fase di compilazione. Prima di ogni chiamata di funzione indiretta, vengono aggiunte altre istruzioni che verificano che la destinazione sia una destinazione di chiamata valida prima della chiamata. Se la destinazione non è una destinazione di chiamata valida, l'applicazione viene terminata. Di conseguenza, solo le applicazioni compilate con il supporto CFG possono trarre vantaggio da questa mitigazione.

Il controllo di una destinazione valida viene fornito dal kernel Windows di destinazione. Quando i file eseguibili vengono caricati, i metadati per le destinazioni di chiamata indirette vengono estratti in fase di caricamento e contrassegnati come destinazioni di chiamata valide. Inoltre, quando la memoria viene allocata e contrassegnata come eseguibile (ad esempio per il codice generato), queste posizioni di memoria vengono contrassegnate anche come destinazioni di chiamata valide, per supportare meccanismi come la compilazione JIT.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Poiché le applicazioni devono essere compilate per supportare CFG, dichiarano implicitamente la compatibilità con essa. La maggior parte delle applicazioni, pertanto, dovrebbe funzionare con questa mitigazione abilitata. Poiché questi controlli vengono compilati nel file binario, la configurazione che puoi applicare è semplicemente per disabilitare i controlli all'interno del kernel Windows kernel. In altre parole, la mitigazione è impostata per impostazione predefinita, ma è possibile configurare il kernel di Windows per restituire sempre "sì" se in seguito si determina che esiste un problema di compatibilità che lo sviluppatore dell'applicazione non ha scoperto nei test, cosa che dovrebbe essere rara.

### <a name="configuration-options"></a>Opzioni di configurazione

**Usa CFG** strict - In modalità strict, tutti i file binari caricati nel processo devono essere compilati per Control Flow Guard (o non contengono codice eseguibile, ad esempio dll di risorse) per poter essere caricati.

> [!Note]
> **Control flow guard** has no audit mode. I file binari vengono compilati con questa mitigazione abilitata.

## <a name="data-execution-prevention-dep"></a>Protezione esecuzione programmi

### <a name="description"></a>Descrizione

Protezione esecuzione programmi impedisce l'esecuzione della memoria non allocata in modo esplicito come eseguibile. Protezione esecuzione programmi consente di proteggersi da un utente malintenzionato che inserisce codice dannoso nel processo, ad esempio tramite un sovraccarico del buffer e quindi eseguendo tale codice.

Se tenti di impostare il puntatore all'istruzione su un indirizzo di memoria non contrassegnato come eseguibile, il processore genererà un'eccezione (violazione di protezione generale), causando l'arresto anomalo dell'applicazione.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Tutti i file eseguibili x64, ARM e ARM-64 hanno protezione esecuzione programmi abilitata per impostazione predefinita e non possono essere disabilitati. Poiché un'applicazione non sarà mai stata eseguita senza Protezione esecuzione programmi, si presuppone la compatibilità.

Per tutti i file binari x86 (32 bit) la funzionalità Protezione esecuzione programmi è abilitata per impostazione predefinita, ma la funzionalità Protezione esecuzione programmi può essere disabilitata per processo. Alcune applicazioni legacy precedenti, in genere le applicazioni sviluppate prima di Windows XP SP2, potrebbero non essere compatibili con Protezione esecuzione programmi. Tali applicazioni in genere generano codice in modo dinamico (ad esempio, compilazione JIT) o collegamenti a librerie precedenti (ad esempio versioni precedenti di ATL) che generano codice in modo dinamico.

### <a name="configuration-options"></a>Opzioni di configurazione

**Abilita emulazione Thunk ATL** - Questa opzione di configurazione disabilita l'emulazione Thunk ATL. ATL, la ActiveX template library, è progettata per essere il più piccola e veloce possibile. Per ridurre le dimensioni binarie, viene utilizzata una tecnica denominata *thunking.* Il thunking viene in genere pensato per interagire tra applicazioni a 32 bit e a 16 bit, ma qui non esistono componenti a 16 bit per ATL. Al contrario, per ottimizzare le dimensioni binarie, ATL archivierà il codice macchina in memoria che non è allineato alle parole (creando un binario più piccolo) e quindi richiama direttamente il codice. I componenti ATL compilati con Visual Studio 7.1 o versioni precedenti (Visual Studio 2003) non allocano questa memoria come eseguibile: l'emulazione thunk risolve il problema di compatibilità. Le applicazioni con un modello di estensione binario (ad esempio Internet Explorer 11) spesso dovranno avere l'emulazione Thunk ATL abilitata.

## <a name="disable-extension-points"></a>Disabilitare i punti di estensione

### <a name="description"></a>Descrizione

Questa mitigazione disabilita diversi punti di estensione per un'applicazione, che potrebbero essere usati per stabilire la persistenza o elevare i privilegi di contenuto dannoso.

Tra questi vi sono anche:

- **DLL AppInit:** ogni volta che viene avviato un processo, il sistema carica la DLL specificata nel contesto del processo appena avviato prima di chiamare la relativa funzione del punto di ingresso. [I dettagli sulle DLL AppInit sono disponibili qui.](/windows/win32/winmsg/about-window-classes#application-global-classes) Con questa mitigazione applicata, le DLL AppInit non vengono caricate. A partire Windows 7, le DLL AppInit devono essere firmate digitalmente, [come descritto qui.](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2) Inoltre, a partire da Windows 8, le DLL AppInit non verranno caricate se SecureBoot è abilitato, come [descritto qui.](/windows/win32/dlls/secure-boot-and-appinit-dlls)
- **IME legacy** - Un IME (Input Method Editor) consente all'utente di digitare testo in una lingua con più caratteri di quelli che possono essere rappresentati su una tastiera. Terze parti sono in grado di creare IME. Un IME dannoso potrebbe ottenere credenziali o altre informazioni riservate da questa acquisizione di input. Alcuni IME, denominati IME legacy, funzionano solo Windows app desktop e non app UWP. Questa mitigazione impedirà anche il caricamento di questo IME legacy nell'app desktop Windows specificata.
- **Windows hook di** evento- Un'applicazione può chiamare l'API [SetWinEventHook](/windows/win32/api/winuser/nf-winuser-setwineventhook) per registrare l'interesse per un evento in corso. Viene specificata una DLL e può essere inserita nel processo. Questa mitigazione forza l'inserimento dell'hook nel processo di registrazione anziché l'esecuzione in-process tramite una DLL inserita.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

La maggior parte di questi punti di estensione viene utilizzata relativamente raramente, quindi l'impatto sulla compatibilità è in genere ridotto, in particolare a livello di singola applicazione. L'unica considerazione è se gli utenti utilizzano IME legacy di terze parti che non funzionano con l'applicazione protetta.

### <a name="configuration-options"></a>Opzioni di configurazione

Non sono disponibili opzioni di configurazione per questa mitigazione.

> [!Note]
> **Disabilitare i punti di estensione** non ha alcuna modalità di controllo.

## <a name="disable-win32k-system-calls"></a>Disabilitare le chiamate di sistema Win32k

### <a name="description"></a>Descrizione

Win32k.sys fornisce un'ampia superficie di attacco per un utente malintenzionato. Come componente in modalità kernel, è spesso destinato come vettore di escape per le applicazioni in modalità sandbox. Questa mitigazione impedisce alle chiamate in win32k.sys bloccando un thread di convertirsi in un thread GUI, a cui viene quindi assegnato l'accesso per richiamare le funzioni Win32k. Un thread non è gui al momento della creazione, ma viene convertito alla prima chiamata a win32k.sys o tramite una chiamata API a [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread).

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Questa mitigazione è progettata per i processi dedicati non dell'interfaccia utente. Ad esempio, molti browser moderni useranno l'isolamento dei processi e incorporano processi non dell'interfaccia utente. Tutte le applicazioni che visualizzano un'interfaccia utente grafica con un singolo processo saranno influenzate da questa mitigazione.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="do-not-allow-child-processes"></a>Non consentire processi figlio

### <a name="description"></a>Descrizione

Questa mitigazione impedisce a un'applicazione di creare nuove applicazioni figlio. Una tecnica comune usata dagli avversari consiste nell'avviare un processo attendibile sul dispositivo con input dannoso (un attacco di tipo "living off the land"), che spesso richiede l'avvio di un'altra applicazione nel dispositivo. Se non esistono motivi legittimi per cui un'applicazione avvii un processo figlio, questa mitigazione riduce il potenziale vettore di attacco. La mitigazione viene applicata impostando una proprietà sul token del processo, che blocca la creazione di un token per il processo figlio con il messaggio di errore STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Se l'applicazione avvia applicazioni figlio per qualsiasi motivo, ad esempio supportando collegamenti ipertestuali che avviano un browser o un browser esterno o che avviano altre utilità nel computer, questa funzionalità verrà interrotta con questa mitigazione applicata.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="export-address-filtering"></a>Esportare il filtro indirizzi

### <a name="description"></a>Descrizione

Il filtro degli indirizzi di esportazione (EAF) riduce il rischio di codice dannoso esaminando la tabella degli indirizzi di esportazione di tutti i moduli caricati per trovare i moduli che contengono API utili per l'attacco. Si tratta di una tattica comune usata da shellcode. Per ridurre il rischio di un attacco di questo tipo, questa mitigazione protegge tre moduli comunemente attaccati:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

La mitigazione protegge la pagina di memoria nella [directory di esportazione che punta alla tabella [degli indirizzi di esportazione.](/windows/win32/debug/pe-format#export-address-table) A questa pagina di memoria [verrà applicata PAGE_GUARD](/windows/win32/memory/creating-guard-pages) protezione. Quando qualcuno tenta di accedere a questa memoria, genererà un STATUS_GUARD_PAGE_VIOLATION. La mitigazione gestisce questa eccezione e se l'istruzione di accesso non supera la convalida, il processo verrà terminato.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Questa mitigazione è principalmente un problema per applicazioni quali debugger, applicazioni in modalità sandbox, applicazioni che utilizzano DRM o applicazioni che implementano la tecnologia anti-debug.

### <a name="configuration-options"></a>Opzioni di configurazione

**Convalidare l'accesso** per i moduli comunemente utilizzati dagli exploit: questa opzione, nota anche come EAF+, aggiunge protezioni per altri moduli comunemente attaccati:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Inoltre, abilitando EAF+, questa mitigazione aggiunge la protezione PAGE_GUARD alla pagina contenente l'intestazione "MZ", i primi due byte dell'intestazione DOS in un [file PE,](/windows/win32/debug/pe-format#ms-dos-stub-image-only)che è un altro aspetto del contenuto di memoria noto che shellcode può cercare per identificare i moduli potenzialmente di interesse per la memoria.

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="force-randomization-for-images-mandatory-aslr"></a>Forza la casualizzazione per le immagini (ASLR obbligatorio)

### <a name="description"></a>Descrizione

Address Space Layout Randomization (ASLR) riduce il rischio che un utente malintenzionato utilizzi la conoscenza del layout di memoria del sistema per eseguire codice già presente nella memoria del processo e già contrassegnato come eseguibile. In questo modo è possibile ridurre il rischio che un utente malintenzionato utilizzi tecniche come gli attacchi da ritorno a libc, in cui l'avversario imposta il contesto e quindi modifica l'indirizzo del mittente per eseguire il codice esistente con un contesto adatto allo scopo dell'avversario.

L'ASLR obbligatorio forza un rebase di tutte le DLL all'interno del processo. Uno sviluppatore può abilitare ASLR usando l'opzione del linker [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019&preserve-view=true) e questa mitigazione ha lo stesso effetto.

Quando il gestore della memoria esegue il mapping dell'immagine nel processo, l'ASLR obbligatorio esegue il rebase forzato delle DLL e degli EXE che non hanno acconsentito esplicitamente ad ASLR. Si noti, tuttavia, che questo sconto non ha entropia e pertanto può essere posizionato in una posizione prevedibile in memoria. Per la posizione basata su base e casuale dei file binari, questa mitigazione deve essere associata alle allocazioni di memoria [randomizzate (ASLR bottom-up).](#randomize-memory-allocations-bottom-up-aslr)

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Questo impatto sulla compatibilità di ASLR è in genere limitato alle applicazioni meno recenti create utilizzando compilatori che presupponevano l'indirizzo di base di un file binario o che hanno privato le informazioni di rilocazione di base. Ciò può causare errori imprevisti quando il flusso di esecuzione tenta di passare alla posizione prevista anziché alla posizione effettiva in memoria.

### <a name="configuration-options"></a>Opzioni di configurazione

**Non consentire immagini stripped-** Questa opzione blocca il caricamento delle immagini per le cui informazioni di rilocazione sono state tortuite. Il formato di file PE di Windows contiene indirizzi assoluti e il compilatore genera anche una [tabella di rilocazione di base che il caricatore può utilizzare per trovare tutti i riferimenti di memoria relativi e il relativo offset, in modo che possano essere aggiornati se il file binario non viene caricato nell'indirizzo di base preferito. Alcune applicazioni precedenti es rimuovere queste informazioni nelle build di produzione e pertanto questi file binari non possono essere ribaseti. Questa mitigazione blocca il caricamento di file binari di questo tipo anziché consentire il caricamento all'indirizzo di base preferito.

> [!Note]
> **Forzare la casualizzazione per le immagini (ASLR obbligatorio)** non ha modalità di controllo.

## <a name="import-address-filtering-iaf"></a>Filtro indirizzi di importazione (IAF)

### <a name="description"></a>Descrizione

La mitigazione del filtro degli indirizzi di importazione (IAF) consente di ridurre il rischio che un avversario cambi il flusso di controllo di un'applicazione modificando la tabella degli indirizzi di importazione (IAT, Import Address Table) per reindirizzare al codice arbitrario scelto dall'autore dell'attacco quando viene chiamata tale funzione. Un utente malintenzionato potrebbe usare questo approccio per dirottare il controllo o intercettare, ispezionare e bloccare potenzialmente le chiamate alle API sensibili.

Alle pagine di memoria per tutte le API protette verrà applicata [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) protezione. Quando qualcuno tenta di accedere a questa memoria, genererà un STATUS_GUARD_PAGE_VIOLATION. La mitigazione gestisce questa eccezione e se l'istruzione di accesso non supera la convalida, il processo verrà terminato.

Questa mitigazione protegge le API Windows seguenti:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Le applicazioni legittime che eseguono l'intercettazione api possono essere rilevate da questa mitigazione e causare l'arresto anomalo di alcune applicazioni. Tra gli esempi sono inclusi gli serre di compatibilità di applicazioni e software di sicurezza.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Allocazioni di memoria casuali (ASLR dal basso verso l'alto)

### <a name="description"></a>Descrizione

Le allocazioni di memoria casuali (ASLR bottom-up) aggiungono entropia alle rilocazioni, quindi la loro posizione è casuale e quindi meno prevedibile. Questa mitigazione richiede l'applicazione dell'aslR obbligatorio.

La dimensione dello spazio degli indirizzi a 32 bit pone vincoli pratici sull'entropia che è possibile aggiungere e pertanto le applicazioni a 64 bit rendono più difficile per un utente malintenzionato indovinare una posizione in memoria.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

La maggior parte delle applicazioni compatibili con l'ASLR obbligatorio (rebasing) è compatibile anche con l'altra entropia di ASLR bottom-up. Alcune applicazioni potrebbero avere problemi di troncamento del puntatore se salvano puntatori locali in variabili a 32 bit (prevedendo un indirizzo di base inferiore a 4 GB) e pertanto non saranno compatibili con l'opzione di entropia elevata (che può essere disabilitata).

### <a name="configuration-options"></a>Opzioni di configurazione

Non usare **l'entropia** elevata: questa opzione disabilita l'uso di ASLR ad alta entropia, che aggiunge 24 bit di entropia (1 TB di varianza) nell'allocazione dal basso verso l'alto per le applicazioni a 64 bit.

> [!Note]
> **Le allocazioni di memoria casuali (ASLR dal basso verso l'alto)** non hanno modalità di controllo.

## <a name="simulate-execution-simexec"></a>Simulazione dell'esecuzione (SimExec)

### <a name="description"></a>Descrizione

L'esecuzione simulata (SimExec) è una mitigazione solo per le applicazioni a 32 bit. Ciò consente di verificare che le chiamate alle API riservate restituiranno le funzioni chiamante legittime. A tale scopo, intercetta le chiamate in API sensibili e quindi simula l'esecuzione di tali API esaminando le istruzioni del linguaggio assembly codificato alla ricerca dell'istruzione RET, che dovrebbe tornare al chiamante. Esamina quindi la funzione e torna indietro nella memoria per trovare l'istruzione CALL precedente per determinare se la funzione e l'istruzione CALL corrispondono e che l'istruzione RET non è stata intercettata.

Le API intercettate da questa mitigazione sono:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Se viene rilevato un gadget ROP, il processo viene terminato.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Le applicazioni che eseguono l'intercettazione delle API, in particolare il software di sicurezza, possono causare problemi di compatibilità con questa mitigazione.

Questa mitigazione non è compatibile con la mitigazione arbitraria di Code Guard.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-api-invocation-callercheck"></a>Convalida chiamata API (CallerCheck)

### <a name="description"></a>Descrizione

Validate API invocation (CallerCheck) è una mitigazione per le tecniche ROP (Return-Oriented Programming) che convalidano che le API sensibili sono state chiamate da un chiamante valido. Questa mitigazione esamina l'indirizzo del mittente passato e quindi disassembla euristicamente all'indietro per trovare una chiamata sopra l'indirizzo del mittente per determinare se la destinazione della chiamata corrisponde al parametro passato alla funzione.

Le API intercettate da questa mitigazione sono:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Se viene rilevato un gadget ROP, il processo viene terminato.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Le applicazioni che eseguono l'intercettazione delle API, in particolare il software di sicurezza, possono causare problemi di compatibilità con questa mitigazione.

Questa mitigazione non è compatibile con la mitigazione arbitraria di Code Guard.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-exception-chains-sehop"></a>Convalida catene di eccezioni (SEHOP)

### <a name="description"></a>Descrizione

Validate exception chains (SEHOP) è una mitigazione rispetto alla tecnica di sfruttamento della sovrascrittura del gestore di eccezioni strutturato *(SEH).* [La gestione delle eccezioni](/windows/win32/debug/structured-exception-handling) strutturata è il processo tramite il quale un'applicazione può chiedere di gestire una determinata eccezione. I gestori delle eccezioni sono concatenati, in modo che se un gestore di eccezioni sceglie di non gestire una determinata eccezione, può essere passato al gestore di eccezioni successivo nella catena finché non si decide di gestirla. Poiché l'elenco del gestore è dinamico, viene archiviato nello stack. Un utente malintenzionato può utilizzare una vulnerabilità di overflow dello stack per sovrascrivere il gestore delle eccezioni con un puntatore al codice scelto dall'utente malintenzionato.

Questa mitigazione si basa sulla progettazione di SEH, in cui ogni voce SEH contiene sia un puntatore al gestore delle eccezioni, sia un puntatore al gestore successivo nella catena di eccezioni. Questa mitigazione viene chiamata dal dispatcher delle eccezioni, che convalida la catena SEH quando viene richiamata un'eccezione. Verifica che:

- Tutti i record della catena di eccezioni sono all'interno dei limiti dello stack
- Tutti i record delle eccezioni sono allineati
- Nessun puntatore del gestore di eccezioni punta a uno stack
- Non sono presenti puntatori all'indietro
- La catena di eccezioni termina in corrispondenza di un gestore eccezioni finale noto

Se queste convalide hanno esito negativo, la gestione delle eccezioni viene interrotta e l'eccezione non verrà gestita.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

I problemi di compatibilità con SEHOP sono relativamente rari. È raro che un'applicazione prenda una dipendenza dal danneggiamento della catena di eccezioni. Tuttavia, alcune applicazioni sono influenzate dalle lievi modifiche della tempistica, che possono manifestarsi come una race condition che rivela un bug latente del multithreading nell'applicazione.

### <a name="configuration-options"></a>Opzioni di configurazione

> [!Note]
> **Validate exception chains (SEHOP)** has no audit mode.

## <a name="validate-handle-usage"></a>Convalidare l'utilizzo dell'handle

### <a name="description"></a>Descrizione

*La convalida dell'utilizzo* degli handle è una mitigazione che consente di proteggere un utente malintenzionato utilizzando un handle esistente per accedere a un oggetto protetto. Un [handle](/windows/win32/sysinfo/handles-and-objects) è un riferimento a un oggetto protetto. Se il codice dell'applicazione fa riferimento a un handle non valido, potrebbe indicare che un avversario sta tentando di utilizzare un handle registrato in precedenza (ma di quale conteggio dei riferimenti dell'applicazione non sarebbe a conoscenza). Se l'applicazione tenta di utilizzare un oggetto non valido, invece di restituire semplicemente null, l'applicazione genererà un'eccezione (STATUS_INVALID_HANDLE).

Questa mitigazione viene applicata automaticamente alle Windows Store.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Le applicazioni che non rilevavano in modo accurato i riferimenti agli handle e che non eseguevano il wrapping di queste operazioni nei gestori di eccezioni potrebbero essere influenzate da questa mitigazione.

### <a name="configuration-options"></a>Opzioni di configurazione

> [!Note]
> **La convalida dell'utilizzo dell'handle** non ha modalità di controllo.

## <a name="validate-heap-integrity"></a>Convalidare l'integrità dell'heap

### <a name="description"></a>Descrizione

La *mitigazione* dell'integrità dell'heap di convalida aumenta il livello di protezione delle mitigazioni dell'heap in Windows, causando la chiusura dell'applicazione se viene rilevato un danneggiamento dell'heap. Le mitigazioni includono:

- Impedire il libero di un handle HEAP
- Esecuzione di un'altra convalida sulle intestazioni di blocco estese per le allocazioni heap
- Verifica che le allocazioni heap non siano già contrassegnate come in uso
- Aggiunta di pagine di protezione a allocazioni, segmenti heap e sottosegmenti di grandi dimensioni superiori a una dimensione minima

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Questa mitigazione è già applicata per impostazione predefinita per le applicazioni a 64 bit e per le applicazioni a 32 bit di destinazione Windows Vista o versioni successive. Le applicazioni legacy di Windows XP o versioni precedenti sono più a rischio, anche se i problemi di compatibilità sono rari.

### <a name="configuration-options"></a>Opzioni di configurazione

> [!Note]
> **La convalida dell'integrità dell'heap** non ha alcuna modalità di controllo.

## <a name="validate-image-dependency-integrity"></a>Convalidare l'integrità delle dipendenze delle immagini

### <a name="description"></a>Descrizione

La *mitigazione della dipendenza* dell'immagine di convalida consente di proteggere dagli attacchi che tentano di sostituire il codice per le DLL collegate in modo statico da Windows binari. La tecnica della distribuzione delle DLL abusa del meccanismo di ricerca del caricatore per inserire codice dannoso, che può essere usato per ottenere l'esecuzione di codice dannoso in un contesto con privilegi elevati. Quando il caricatore carica un file binario firmato Windows e quindi carica tutte le DLL da cui dipende il file binario, questi file binari verranno verificati per assicurarsi che siano firmati anche digitalmente come file binario Windows. In caso di esito negativo del controllo della firma, la dll non verrà caricata e genererà un'eccezione, che restituirà lo stato STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

I problemi di compatibilità non sono comuni. Le applicazioni che dipendono dalla sostituzione dei file binari di Windows con versioni private locali saranno interessate e vi è anche un piccolo rischio di rivelare bug di temporizzazione sottili nelle applicazioni multi-thread.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-stack-integrity-stackpivot"></a>Convalidare l'integrità dello stack (StackPivot)

### <a name="description"></a>Descrizione

La mitigazione dell'integrità dello stack di convalida *(StackPivot)* consente di proteggere dall'attacco Stack Pivot, un attacco ROP in cui un utente malintenzionato crea uno stack fittizio nella memoria heap e quindi inganna l'applicazione per tornare allo stack falso che controlla il flusso di esecuzione.

Questa mitigazione intercetta Windows API ed esamina il valore del puntatore dello stack. Se l'indirizzo del puntatore dello stack non si trova tra la parte inferiore e la parte superiore dello stack, viene registrato un evento e, se non è in modalità di controllo, il processo verrà terminato.

Le API intercettate da questa mitigazione sono:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Considerazioni sulla compatibilità

Le applicazioni che utilizzano stack falsi saranno influenzate e c'è anche un piccolo rischio di rivelare bug di temporizzazione sottili nelle applicazioni multi-thread.
Le applicazioni che eseguono l'intercettazione delle API, in particolare il software di sicurezza, possono causare problemi di compatibilità con questa mitigazione.

Questa mitigazione non è compatibile con la mitigazione arbitraria di Code Guard.

### <a name="configuration-options"></a>Opzioni di configurazione

**Solo controllo:** è possibile abilitare questa mitigazione in modalità di controllo per misurare il potenziale impatto sulla compatibilità di un'applicazione. Gli eventi di controllo possono quindi essere visualizzati nel visualizzatore eventi o usando Ricerca avanzata in [Microsoft Defender per Endpoint.](/microsoft-365/security/defender/advanced-hunting-overview)
